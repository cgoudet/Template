#include <iostream>
#include "InvertMatrix.h"
#include "TMath.h"
#include "boost/multi_array.hpp"
#include "RooRealVar.h"
#include <vector>
#include "RooArgList.h"
#include "RooCategory.h"
#include "RooSimultaneous.h"
#include "RooGaussian.h"
#include "RooFormulaVar.h"
#include "RooArgSet.h"
#include <map>
#include "RooDataSet.h"
#include <string>
#include "RooConstVar.h"

using std::copysign;
using std::string;
using std::map;
using std::vector;
using TMath::Power;
using std::cout;
using std::endl;
using boost::multi_array;
using boost::extents;

using namespace RooFit;

void Style_Christophe();


void InvertMatrix( TMatrixD &combinMatrix, TMatrixD &combinErrMatrix, TMatrixT<double>& outMatrix, TMatrixT<double> &outErrMatrix, unsigned int inputType, unsigned int inversionProcedure ) {
  /*
    InputType :
    0 : alpha
    1 : sigma
  
    Inversion Procedure 
    0 : inversion matrix
    1 : fit
  */

  unsigned int nBins = (unsigned int ) combinMatrix.GetNrows();

  switch ( inversionProcedure ) {

  case 0 : {
    //Create the B matrix for alpha
    TMatrixD *bMatrix = new TMatrixD( nBins, 1);
    TMatrixD *UMatrix = new TMatrixD( nBins, nBins );  

    //Inversion code stolen directly from Template::InvertMatrix the 22nd July 2015
    //No modification except for variables names
    for ( unsigned int line = 0; line < nBins; line++ ) {
      for ( unsigned int col = 0; col < nBins; col++ ) {
	if ( combinErrMatrix( line, col ) <= 0 ) {
	  cout << "combinErrMatrix has negative values." << endl;
	  return ;
	}
 
	switch ( inputType ) {
	case 0 : {
	  (*bMatrix)(line, 0 ) += combinMatrix(line, col ) /  combinErrMatrix( line, col) / combinErrMatrix( line, col) * ( 1 + Delta( col, line ) ); 
	  (*UMatrix)( line, col ) += 1. / 2 / combinErrMatrix( line, col ) / combinErrMatrix( line, col ) * ( 1 +Delta( line, col ) );
	  (*UMatrix)( line, line ) += 1. / 2 / combinErrMatrix( line, col ) / combinErrMatrix( line, col ) * ( 1 +  Delta( line, col ) );
	  break;	
	}
	case 1 : {
	  if ( combinMatrix(line, col) < 0 ) {
	    cout << "combinMatrix in Sigma inputType has negative value." << endl;
	    return ;
	  }

	  (*bMatrix)( line, 0)    += ( 1. + Delta( col, line ) ) * combinMatrix( line, col ) * combinMatrix( line, col )  / Power( 2 * combinErrMatrix( line, col) * combinMatrix( line, col) + Power( combinErrMatrix( line, col), 2 ), 2 ) ;
	  (*UMatrix)( line, col)  += (1+Delta( col, line )) / 2. / Power( 2 * combinErrMatrix( line, col) * combinMatrix( line, col) + Power( combinErrMatrix( line, col), 2 ), 2 );
	  (*UMatrix)( line, line) += ( 1. + Delta( col, line ) ) / 2. / Power( 2 * combinErrMatrix( line, col) * combinMatrix( line, col) + Power( combinErrMatrix( line, col), 2 ), 2 );
	  break;
	}
	default :
	  cout << "inputType " << inputType << "not supporting in inversionProcedure " << inversionProcedure << endl;
	  return;
	}

      }}
  
    UMatrix->Print();
    UMatrix->Invert();
    outMatrix = TMatrixD( nBins, 1);
    outErrMatrix = TMatrixD( nBins, 1);
    outMatrix = (*UMatrix) * (*bMatrix);
    for ( unsigned int iBin=0; iBin < nBins; iBin++ ) {
      switch ( inputType ) {
      case 0 :
	outErrMatrix(iBin, 0) = sqrt( 2* (*UMatrix)(iBin, iBin) );
	break;
      case 1 :
	outMatrix(iBin,0) = SignSquare( outMatrix(iBin, 0) );
	outErrMatrix(iBin, 0) = ErrC( outMatrix(iBin,0), (*UMatrix)(iBin, iBin) );
	break;
      default :
	cout << "inputType " << inputType << "not supporting in inversionProcedure " << inversionProcedure << endl;
	return;

      }//end switch inputType
    }
    break;
  }//end case 0 inversionProcedure

  case 1 : { //inversionProcedure
    //Defining observables
    RooRealVar *alpha = new RooRealVar( "alpha", "alpha", -0.1, 0.1 );
    RooRealVar *alphaErr = new RooRealVar( "alphaErr", "alphaErr", 0, 1e3 );
    RooArgSet *observables = new RooArgSet( RooArgSet( *alpha ), "observables" );
    map< string, RooDataSet*> datasetMap;
    
    vector<RooRealVar*> alphaBin;
    multi_array<RooFormulaVar*, 2> alphaConfig;
    multi_array<RooConstVar*, 2> alphaErrConfig;
    RooCategory* channellist = new RooCategory("channellist","channellist");
    RooSimultaneous *combinedPdf = new RooSimultaneous("CombinedPdf","",*channellist); 

    for (unsigned int iLine = 0; iLine < (unsigned int) combinMatrix.GetNrows(); iLine ++) {
      alphaBin.push_back(0);
      alphaConfig.resize( extents[iLine+1][iLine+1] );
      alphaErrConfig.resize( extents[iLine+1][iLine+1] );

      for ( unsigned iCol = 0; iCol<=iLine ; iCol++ ) {

	//Create the roorealvar for bin iLine
	TString configName = TString::Format( "Config_%d_%d", iLine, iCol );      
	channellist->defineType( configName );
	TString alphaName;
	switch ( inputType ) {
	case 0 : //alpha
	  if ( !alphaBin.back() ) {
	    alphaName = TString::Format( "alpha_%d", iLine );
	    alphaBin.back() = new RooRealVar( alphaName, alphaName, 0, -0.1, 0.1 );
	  }

	  alphaName = TString::Format( "alphaConf_%d_%d", iLine, iCol );
	  alphaConfig[iLine][iCol] = new RooFormulaVar( alphaName, alphaName, "(@0+@1)/2.", RooArgList( *alphaBin[iLine], *alphaBin[iCol] ) );
	  alphaName = TString::Format( "alphaErrConf_%d_%d", iLine, iCol );
	  alphaErrConfig[iLine][iCol] = new RooConstVar( alphaName, alphaName, combinErrMatrix( iLine, iCol ) );
	  break;

	case 1 : {//constant term
	  if ( !alphaBin.back() ) {
	    alphaName = TString::Format( "C2_%d", iLine );
	    alphaBin.back() = new RooRealVar( alphaName, alphaName, combinMatrix( iLine, iCol ), 0, 0.1 );
	  }
	  alphaName = TString::Format( "CConf_%d_%d", iLine, iCol );
	  alphaConfig[iLine][iCol] = new RooFormulaVar( alphaName, alphaName, "TMath::Sqrt((@0*@0+@1*@1)/2.)", RooArgList( *alphaBin[iLine], *alphaBin[iCol] ) );
	  alphaName = TString::Format( "C2ErrConf_%d_%d", iLine, iCol );
	  alphaErrConfig[iLine][iCol] = new RooConstVar( alphaName, alphaName, combinErrMatrix( iLine, iCol ) );
	  break;
	}

	default :
	  cout << "inputType " << inputType << "not supporting in inversionProcedure " << inversionProcedure << endl;
	  return;
	}// end switch inputType
	if ( iLine == iCol ) alphaBin[iLine]->setVal( combinMatrix[iLine][iLine] );	

	//Create the model for the configuration
	RooGaussian *configPdf = new RooGaussian( "Gauss_" + configName, "Gauss_" + configName , *alpha, *alphaConfig[iLine][iCol], *alphaErrConfig[iLine][iCol] ); 	
	combinedPdf->addPdf( *configPdf, configName );
	
	//Create the dataset
	alpha->setVal( combinMatrix(iLine, iCol) );
	alphaErr->setVal( combinErrMatrix(iLine, iCol) );
	RooDataSet *configData = new RooDataSet( "Data_" + configName, "Data_" + configName, *observables );
	configData->add( *observables );
	//	configData->Print("v");
	datasetMap[string(configName)] = configData;
      }//end iCol
    }// end iLine

    
    RooDataSet* obsData = new RooDataSet("obsData","combined data ",*observables, Index(*channellist), Import(datasetMap)); 
    combinedPdf->Print();
    combinedPdf->fitTo( *obsData );
    
    outMatrix = TMatrixD( nBins, 1 );
    outErrMatrix = TMatrixD( nBins, 1 );
    //FillThe result Matrix
    for (unsigned int iLine = 0; iLine < nBins; iLine ++) {
      switch ( inputType ) {
      case 0 : //alpha
	outMatrix(iLine, 0) = alphaBin[iLine]->getVal();
	outErrMatrix(iLine, 0) = alphaBin[iLine]->getError();
	break;
      case 1 ://sigma
	outMatrix(iLine, 0) = alphaBin[iLine]->getVal();
	outErrMatrix(iLine, 0) = alphaBin[iLine]->getError();
	break;
      }//end switch inputType
    }//end for
    break;
  }//end case 1 invettionProcedure

  default : 
    cout << "input inversionProcedure do not corresponds do any case available" << endl;
  }//end switch inversionProcedure 
  
  // cout << "Out switch " << endl;
  // cout << "outMatrix : " << outMatrix << endl;
  // cout << "outErrMatrix : " << outErrMatrix << endl;
    
}


//============================

unsigned int Delta( unsigned int i, unsigned int j ) { 
  return ( i == j ) ? 1 : 0 ; };

//====================================================
double SignSquare( double inVal ) {
  return copysign( sqrt( fabs( inVal ) ), inVal );
}

//==========================================
double ErrC( double c, double errC2 ) {
  return sqrt( c*c + sqrt( 2 * errC2 ) ) - fabs(c);

}
