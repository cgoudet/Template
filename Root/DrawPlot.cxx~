#include <iostream>
#include "TCanvas.h"
#include "TLegend.h"
#include "TLine.h"
using std::cout;
using std::endl;
using std::min;
using std::max;

#include "Template/DrawPlot.h"

void Style_Christophe();
int colors[] = {1, 2, 4, 6, 8, 28, 46};

int RatioPlot( vector< TH1* > inHist,  
	       string outName, 
	       vector< string> inLegend, 
	       unsigned int doRatio, 
	       bool normalize, 
	       bool doChi2, 
	       bool centerZoom , 
	       vector<double> rangeUser, 
	       vector<double> legendCoord,
	       vector<string> latex,
	       vector<vector<<double>> latexPos
	       ) {

		 //========================
		 if ( inLegend.size() && inLegend.size()!=inHist.size() ) {
		   cout << "Legend do not match input" << endl;
		   exit( 1 );
  }
		 
		 
		 Style_Christophe();
		 
		 if ( inHist.size() < 2 ) doRatio = 0;
  vector<double> chi2( inHist.size()-1, 0 );

  TCanvas *canvas = new TCanvas();
  TPad *padUp = new TPad( "padUp", "padUp", 0, 0.3, 1, 1 );
  padUp->SetBottomMargin( 0 );
  padUp->SetLeftMargin( 0.07 );
  TPad *padDown = new TPad( "padDown", "padDown", 0, 0, 1, 0.3 );
  padDown->SetTopMargin( 0 );
  padDown->SetBottomMargin( 0.2 );
  padDown->SetLeftMargin( 0.07 );

  if ( doRatio ) {
    padUp->Draw();
    canvas->cd();
    padDown->Draw();
    padUp->cd();
  }

  if ( !legendCoord.size() ) legendCoord={ 0.7, 0.8, 0.99, 0.99 };
  TLegend *legend = new TLegend( legendCoord[0], legendCoord[1], legendCoord[2], legendCoord[3]);
  legend->SetFillColorAlpha( 0, 0 );
  legend->SetLineColorAlpha( 0, 0 );

  //Find the extremum of the histograms to choose rangeUser if not given
  double minVal, maxVal, minX=0, maxX=0;
  for ( unsigned int iHist = 0; iHist < inHist.size(); iHist++ ) {

    if ( normalize && inHist[iHist]->Integral() ) inHist[iHist]->Scale( 1./inHist[iHist]->Integral() );
    minVal = inHist.front()->GetMinimum();
    maxVal = inHist.front()->GetMaximum();

    for ( int bin = 1; bin <= inHist[iHist]->GetNbinsX(); bin++ ) {
      minVal = min( inHist[iHist]->GetBinContent( bin ) - inHist[iHist]->GetBinError( bin ), minVal );
      maxVal = max( inHist[iHist]->GetBinContent( bin ) + inHist[iHist]->GetBinError( bin ), maxVal );
    }
    
    if ( rangeUser.size() == 2 ) inHist.front()->GetYaxis()->SetRangeUser( rangeUser[0], rangeUser[1] );
    else inHist.front()->GetYaxis()->SetRangeUser( minVal - ( maxVal - minVal ) *0.05 , maxVal + ( maxVal - minVal ) *0.05 );

    //Reduce the X range to filled bins
    int lowBin = 1, upBin = inHist[iHist]->GetNbinsX();
    while ( inHist[iHist]->GetBinContent( lowBin ) == 0 && lowBin!=upBin ) lowBin++;
    while ( inHist[iHist]->GetBinContent( upBin ) ==0 && lowBin!=upBin ) upBin--;
    if ( lowBin != upBin ) {
      if ( !iHist || minX > inHist[iHist]->GetXaxis()->GetBinLowEdge( lowBin ) ) minX = inHist[iHist]->GetXaxis()->GetBinLowEdge( lowBin );
      if ( !iHist || maxX < inHist[iHist]->GetXaxis()->GetBinUpEdge( upBin ) ) maxX = inHist[iHist]->GetXaxis()->GetBinUpEdge( upBin );
      if ( centerZoom ) inHist.front()->GetXaxis()->SetRangeUser( minX, maxX );
    }
    inHist[iHist]->SetLineColor( colors[iHist ] );

    
    if ( doRatio ){
      for ( int iBin = 1; iBin < inHist[iHist]->GetNbinsX(); iBin++ ) {
	chi2[iHist]+=  ( inHist[iHist]->GetBinError(iBin) ==0 && inHist.front()->GetBinError(iBin) ==0 ) ? 0 :
	  (inHist[iHist]->GetBinContent( iBin ) - inHist.front()->GetBinContent( iBin ) )*(inHist[iHist]->GetBinContent( iBin ) - inHist.front()->GetBinContent( iBin ) ) 
	  / ( inHist.front()->GetBinError( iBin ) * inHist.front()->GetBinError( iBin ) + inHist[iHist]->GetBinError( iBin ) * inHist[iHist]->GetBinError( iBin ) );
      }
      chi2[iHist] /= inHist[iHist]->GetNbinsX();
    }
    inHist[iHist]->Draw( (iHist) ? "e,same" : "e" );
    if ( !iHist ) {
      inHist.front()->GetYaxis()->SetTitleOffset( 0.6 );
      inHist.front()->GetYaxis()->SetTitleSize( 0.06 );
    }
    string legendText = (inLegend.size()) ? inLegend[iHist].c_str() : inHist[iHist]->GetName();
    if ( doChi2 && iHist ) legendText += " : chi2=" + TString::Format( "%2.2f", chi2[iHist] );
    legend->AddEntry( inHist[iHist], legendText.c_str(), "lpe" );


  }//end iHist

  TLine *line = new TLine( 0, 0.005, 100, 0.005);
  line->SetLineColor( kBlack );
  line->SetLineStyle( 3 );

  legend->Draw();

  if ( doRatio ) {
    padDown->cd();
    vector< TH1F* > ratio;
    double minValRatio = 0;
    double maxValRatio = 0;
    for ( unsigned int iHist = 1; iHist < inHist.size(); iHist++ ) {
      ratio.push_back( 0 );
      ratio.back() = (TH1F*) inHist[iHist]->Clone();
      ratio.back()->Add( inHist.front(), -1 );
      if ( doRatio == 1 ) ratio.back()->Divide( inHist.front() );
      if ( iHist == 1 ) {
	ratio.back()->GetXaxis()->SetTitle( inHist.front()->GetXaxis()->GetTitle() );
	ratio.back()->GetXaxis()->SetLabelSize( 0.1 );
	ratio.back()->GetXaxis()->SetTitleSize( 0.1 );
	ratio.back()->GetYaxis()->SetLabelSize( 0.05 );
	ratio.back()->GetYaxis()->SetTitleSize( 0.1 );
	ratio.back()->GetYaxis()->SetTitleOffset( 0.3 );
	ratio.back()->GetXaxis()->SetTitleOffset( 0.7 );
	ratio.back()->SetTitle("");
	if ( doRatio ==  1 ) ratio.back()->GetYaxis()->SetTitle( "#frac{h1-h0}{h0}" );
	else ratio.back()->GetYaxis()->SetTitle( "h1-h0" );
      }

      for ( int bin = 1; bin <= ratio.back()->GetNbinsX(); bin++ ) {
	//	cout << minValRatio << " " << maxValRatio << endl;
	minValRatio = min( ratio.back()->GetBinContent(bin) - ratio.back()->GetBinError( bin), minValRatio );
	maxValRatio = max( ratio.back()->GetBinContent(bin)+ ratio.back()->GetBinError( bin ), maxValRatio );

      }
    }


    ratio.front()->GetYaxis()->SetRangeUser( minValRatio - (maxValRatio-minValRatio)*0.05, maxValRatio+(maxValRatio-minValRatio)*0.05 );
    for ( unsigned int iHist = 0; iHist < ratio.size(); iHist++ ) {
      ratio[iHist]->Draw( ( iHist ) ? "e,same" : "e" );
    }
    line->DrawLine( ratio.front()->GetXaxis()->GetXmin(), 0, ratio.front()->GetXaxis()->GetXmax(), 0);
  }

  canvas->SaveAs( TString(outName) + ".pdf" );
  //  canvas->SaveAs( TString(outName) + ".png" );
  delete canvas;
  return 0;
}
